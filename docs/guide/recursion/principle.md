# 递归原理

>递归是一种解决问题的有效方法，在递归过程中，函数将自身作为子例程调

你可能想知道如何实现调用自身的函数。诀窍在于，每当递归函数调用自身时，它都会将给定的问题拆解为子问题。递归调用继续进行，直到到子问题无需进一步递归就可以解决的地步。

为了确保递归函数不会导致无限循环，它应具有以下属性：

1. 一个简单的 `基本案例（basic case）`（或一些案例） —— 能够不使用递归来产生答案的终止方案。
2. 一组规则，也称作 `递推关系（recurrence relation）`，可将所有其他情况拆分到基本案例。

注意，函数可能会有多个位置进行自我调用。

#### 示例

让我们从一个简单的编程问题开始：

> 以相反的顺序打印字符串。

你可以使用迭代的办法轻而易举地解决这个问题，即从字符串的最后一个字符开始遍历字符串。但是如何递归地解决它呢？

首先，我们可以将所需的函数定义为 `printReverse(str[0...n-1])`，其中 `str[0]` 表示字符串中的第一个字符。然后我们可以分两步完成给定的任务：

1. `printReverse(str[1...n-1])`：以相反的顺序打印子字符串 `str[1...n-1]`。
2. `print(str[0])`：打印字符串中的第一个字符。

请注意，我们在第一步中调用函数本身，根据定义，它使函数递归。

下面给出了代码片段：

```js
function printReverse(str) {
  helper(0, str);
}

function helper(index, str) {
  if (index >= str.length) {
    return;
  }
  helper(index + 1, str);
  console.log(str[index]);
}
```

接下来，你将会发现一个与上述示例稍有不同的练习。你应该尝试使用递归来解决它。

*注意*：对于本练习中，我们还在本 “探索” 章节中提供了详细的解决方案。
